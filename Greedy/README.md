# 贪心算法

## 一.贪心算法概要

### 1.什么是贪心

**「贪心的本质是选择每一阶段的局部最优，从而达到全局最优」**。

这么说有点抽象，来举一个例子：

例如，有一堆钞票，你可以拿走十张，如果想达到最大的金额，你要怎么拿？ 

指定每次拿最大的，最终结果就是拿走最大数额的钱。每次拿最大的就是局部最优，最后拿走最大数额的钱就是推出全局最优。

再举一个例子：

如果是 有一堆盒子，你有一个背包体积为n，如何把背包尽可能装满，如果还每次选最大的盒子，就不行了。这时候就需要动态规划。动态规划的问题在下一个系列会详细讲解。

### 2.贪心的套路

**「说实话贪心算法并没有固定的套路」**。

+ 所以唯一的难点就是如何通过局部最优，推出整体最优。

那么如何能看出局部最优是否能推出整体最优呢？有没有什么固定策略或者套路呢？

+  **「不好意思，也没有！」** 靠自己手动模拟，如果模拟可行，就可以试一试贪心策略，如果不可行，可能需要动态规划。

有同学问了如何验证可不可以用贪心算法呢？

+ **「最好用的策略就是举反例，如果想不到反例，那么就试一试贪心吧」**。

### 3.贪心的一般解题步骤

贪心算法一般分为如下四步：

- 将问题分解为若干个子问题
- 找出适合的贪心策略
- 求解每一个子问题的最优解
- 将局部最优解堆叠成全局最优解

其实这个分的有点细了，真正做题的时候很难分出这么详细的解题步骤，可能就是因为贪心的题目往往还和其他方面的知识混在一起。



## 二.刷题积累

### 1.分发饼干

> 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。
>
> 对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

+ **示例：**

  <div align = center><img src="../images/Greedy1.png" width="500px" /></div>

+ **思路：**

  + 为了了满足更多的小孩，就不要造成饼干尺寸的浪费。大尺寸的饼干既可以满足胃口大的孩子也可以满足胃口小的孩子，那么就应该优先满足胃口大的。
  +  **「这里的局部最优就是大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩」**。
  + 可以尝试使用贪心策略，先将饼干数组和小孩数组排序。
  + 然后从后向前遍历小孩数组，用大饼干优先满足胃口大的，并统计满足小孩数量。

  <div  align = center><img src="../images/Greedy2.png" width="600px" /></div>

+ **代码实现：**

  ```c++
  // 时间复杂度：O(nlogn)
  // 空间复杂度：O(1)
  class Solution {
  public:
      int findContentChildren(vector<int>& g, vector<int>& s) {
          sort(g.begin(), g.end());
          sort(s.begin(), s.end());
          int index = s.size() - 1; // 饼干数组的下表
          int result = 0;
          for (int i = g.size() - 1; i >= 0; i--) {
              if (index >= 0 && s[index] >= g[i]) {
                  result++;
                  index--;
              }
          }
          return result;
      }
  };
  ```

### 2.摆动序列(376)

> 如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。
>
> 例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。
>
> 给定一个整数序列，返回作为摆动序列的最长子序列的长度。通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。

+ **示例：**

  <div  align = center><img src="../images/Greedy3.png" width="700px" /></div>

+ **思路：**

  + 本题要求通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。来分析一下，要求删除元素使其达到最大摆动序列，应该删除什么元素呢？用示例二来举例，如图所示：

    <div  align = center><img src="../images/Greedy4.png" width="700px" /></div>

  +  **「局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值」**。

  +  **「整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列」**。

  + **「实际操作上，其实连删除的操作都不用做，因为题目要求的是最长摆动子序列的长度，所以只需要统计数组的峰值数量就可以了（相当于是删除单一坡度上的节点，然后统计长度）」** 。 **「这就是贪心所贪的地方，让峰值尽可能的保持峰值，然后删除单一坡度上的节点」**。

+ **代码实现：**

  ```c++
  class Solution {
  public:
      int wiggleMaxLength(vector<int>& nums) {
          if (nums.size() <= 1) return nums.size();
          int curDiff = 0; // 当前一对差值
          int preDiff = 0; // 前一对差值
          int result = 1;  // 记录峰值个数，序列默认序列最右边有一个峰值
          for (int i = 1; i < nums.size(); i++) {
              curDiff = nums[i] - nums[i - 1];
              // 出现峰值
              if ((curDiff > 0 && preDiff <= 0) || (preDiff >= 0 && curDiff < 0)) {
                  result++;
                  preDiff = curDiff;
              }
          }
          return result;
      }
  };
  ```

  

### 3.最大子序和(53)

> 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

+ **示例：**

  <div  align = center><img src="../images/Greedy5.png" width="500px" /></div>

+ **思路：**

  + 局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。
  + 全局最优：选取最大“连续和”
  + **「局部最优的情况下，并记录最大的“连续和”，可以推出全局最优」**。

  <div  align = center><img src="../images/Greedy6.gif" width="500px" /></div>

  + 红色的起始位置就是贪心每次取count为正数的时候，开始一个区间的统计。

+ **代码实现：**

  ```c++
  class Solution {
  public:
      int maxSubArray(vector<int>& nums) {
          int result = INT32_MIN;
          int count = 0;
          for (int i = 0; i < nums.size(); i++) {
              count += nums[i];
              if (count > result) { // 取区间累计的最大值（相当于不断确定最大子序终止位置）
                  result = count;
              }
              if (count <= 0) count = 0; // 相当于重置最大子序起始位置，因为遇到负数一定是拉低总和
          }
          return result;
      }
  };
  ```

  

