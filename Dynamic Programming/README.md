# 动态规划算法

## 一.动态规划概要

动态规划，英文：Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。

所以动态规划中每一个状态一定是由上一个状态推导出来的，**这一点就区分于贪心**，贪心没有状态推导，而是从局部直接选最优的。

例如：有N件物品和一个最多能背重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和最大。

动态规划中dp[j]是由dp[j-weight[i]]推导出来的，然后取max(dp[j], dp[j - weight[i]] + value[i])。

但如果是贪心呢，每次拿物品选一个最大的或者最小的就完事了，和上一个状态没有关系。

所以贪心解决不了动态规划的问题。

## 二.动态规划解题步骤

**对于动态规划问题，拆解为如下五步曲，这五步都搞清楚了，就能动态规划真的掌握了！**

- **确定dp数组（dp table）以及下标的含义**
- **确定递推公式**
- **dp数组如何初始化**
- **确定遍历顺序**
- **举例推导dp数组**

## 三.动态规划debug方式

写动规题目时，如果代码出问题很正常！

**找问题的最好方式就是把dp数组打印出来，看看究竟是不是按照自己思路推导的！**

**做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果**。

然后再写代码，如果代码没通过就打印dp数组，看看是不是和自己预先推导的哪里不一样。

如果打印出来和自己预先模拟推导是一样的，那么就是自己的递归公式、初始化或者遍历顺序有问题了。

如果和自己预先模拟推导的不一样，那么就是代码实现细节有问题。

**这样才是一个完整的思考过程，而不是一旦代码出问题，就毫无头绪的东改改西改改，最后过不了，或者说是稀里糊涂的过了**。

这也是为什么在动规五步曲里强调推导dp数组的重要性。

如果没有被AC，可以从这三个方面入手检查：

- **这道题目我举例推导状态转移公式了么？**
- **我打印dp数组的日志了么？**
- **打印出来了dp数组和我想的一样么？**

**如果这灵魂三问自己都做到了，基本上这道题目也就解决了**，或者更清晰的知道自己究竟是哪一点不明白，是状态转移不明白，还是实现代码不知道该怎么写，还是不理解遍历dp数组的顺序。



## 四.刷题积累

 ### 1.斐波那契数(509)

> 斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：
> F(0) = 0，F(1) = 1
> F(n) = F(n - 1) + F(n - 2)，其中 n > 1
> 给你n ，请计算 F(n) 。

+ **动态规划五部曲：**

  1. **确定dp数组以及下标的含义**
     + dp[i]的定义为：第i个数的斐波那契数值是dp[i]

  2. **确定递推公式**
     + 为什么这是一道非常简单的入门题目呢？
     + **因为题目已经把递推公式直接给我们了：状态转移方程 dp[i] = dp[i - 1] + dp[i - 2];**

  3. **dp数组如何初始化**

     + **题目中把如何初始化也直接给我们了，如下：**

     ```c++
     dp[0] = 0;
     dp[1] = 1;
     ```

  4. **确定遍历顺序**

     + 从递归公式`dp[i] = dp[i - 1] + dp[i - 2];`中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的

  5. **举例推导dp数组**

     + 按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]，我们来推导一下，当N为10的时候，dp数组应该是如下的数列： 0 1 1 2 3 5 8 13 21 34 55
     + 如果代码写出来，发现结果不对，就把dp数组打印出来看看和我们推导的数列是不是一致的。

+ **代码实现：**

  ```c++
  class Solution {
  public:
      int fib(int n) {
          if(n <= 1)
              return n;
          //1.确定数组和下标意义
          int dp[2];
          //2.确定递推公式
          //dp[i] = dp[i - 1] + dp[1 - 2];
          //3.dp数组初始化
          dp[0] = 0;
          dp[1] = 1;
          //4.确定遍历顺序
          int sum = 0;
          for(int i = 2; i <= n; ++i) {
            //5.推导dp数组
              sum = dp[0] + dp[1];
              dp[0] = dp[1];
              dp[1] = sum;
          }
          return sum;
      }
  };
  ```



### 2. 使用最小花费爬楼梯(746)

> 数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。
>
> 每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。
>
> 请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。
>
> 提示：
>
> - cost 的长度范围是 [2, 1000]。
> - cost[i] 将会是一个整型数据，范围为 [0, 999] 。

+ **示例：**

  <div align = center><img src="../images/DP1.png" width="700px" /></div>

+ **思路：**

  +  **注意题目描述：每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。** 所以示例1中只花费一个15 就可以到阶梯顶，最后一步可以理解为 不用花费。

  + **动态规划五部曲：**

    + **确定dp数组以及下标的含义**

      + 使用动态规划，就要有一个数组来记录状态，本题只需要一个一维数组dp[i]就可以了。
      +  **dp[i]的定义：第i个台阶所花费的最少体力为dp[i]**。

    + **确定递推公式**

      +  **可以有两个途径得到dp[i]，一个是dp[i-1] 一个是dp[i-2]**。
      +  选dp[i-1]与dp[i-2]中更小的，所以`dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];`
      + **注意这里为什么是加cost[i]，而不是cost[i-1],cost[i-2]之类的** ，因为题目中说了：每当你爬上一个阶梯你都要花费对应的体力值

    + **dp数组如何初始化**

      + dp[i]由dp[i-1]，dp[i-2]推出，既然初始化所有的dp[i]是不可能的，那么只初始化dp[0]和dp[1]就够了，其他的最终都是dp[0]dp[1]推出。

    + **确定遍历顺序**

      + 因为是模拟台阶，而且dp[i]又dp[i-1]dp[i-2]推出，所以是从前到后遍历cost数组就可以了。

    + **举例推导dp数组**

      + 拿示例2：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] ，来模拟一下dp数组的状态变化，如下：

        <div align = center><img src="../images/DP2.png" width="700px" /></div>

+ **代码实现：**

  ```c++
  // 版本一
  class Solution {
  public:
      int minCostClimbingStairs(vector<int>& cost) {
          vector<int> dp(cost.size());
          dp[0] = cost[0];
          dp[1] = cost[1];
          for (int i = 2; i < cost.size(); i++) {
              dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];
          }
          // 注意最后一步可以理解为不用花费，所以取倒数第一步，第二步的最少值
          return min(dp[cost.size() - 1], dp[cost.size() - 2]);
      }
  };
  // 版本二
  class Solution {
  public:
      int minCostClimbingStairs(vector<int>& cost) {
          int dp0 = cost[0];
          int dp1 = cost[1];
          for (int i = 2; i < cost.size(); i++) {
              int dpi = min(dp0, dp1) + cost[i];
              dp0 = dp1; // 记录一下前两位
              dp1 = dpi;
          }
          return min(dp0, dp1);
      }
  };
  ```

  

### 3.不同路径(62)

> 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
>
> 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
>
> 问总共有多少条不同的路径？

+ **示例：**

  <div align = center><img src="../images/DP3.png" width="700px" /></div>

+ **动态规划五部曲：**

  + **确定dp数组（dp table）以及下标的含义**

    + dp[i][j] ：表示从（0 ，0）出发，到(i, j) 有dp[i][j]条不同的路径。

  + **确定递推公式**

    + 想要求dp[i][j]，只能有两个方向来推导出来，即dp[ i - 1] [ j] 和 dp[i] [j - 1]。
    + dp[i - 1] [j] 表示的是从(0, 0)的位置到(i - 1, j)有几条路径，dp[i] [j - 1]同理。
    + 那么很自然，dp[i] [j] =  dp[i - 1] [j] + dp[i] [j - 1]，因为dp[i] [j]只有这两个方向过来。

  + **dp数组的初始化**

    + 首先dp[i] [0]一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条，那么dp[0] [j]也同理。

  + **确定遍历顺序**

    + 这里要看一下递归公式dp[i] [j] =  dp[i - 1] [j] + dp[i] [j - 1]，dp[i] [j]都是从其上方和左方推导而来，那么从左到右一层一层遍历就可以了。
    + 这样就可以保证推导dp[i] [j]的时候，dp[i - 1] [j] 和 dp[i] [j - 1]一定是有数值的。

  + **举例推导dp数组**

    <div align = center><img src="../images/DP4.png" width="500px" /></div>

+ **代码实现：**

  ```c++
  class Solution {
  public:
      int uniquePaths(int m, int n) {
          vector<vector<int>> dp(m, vector<int>(n, 0));
          for (int i = 0; i < m; i++) dp[i][0] = 1;
          for (int j = 0; j < n; j++) dp[0][j] = 1;
          for (int i = 1; i < m; i++) {
              for (int j = 1; j < n; j++) {
                  dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
              }
          }
          return dp[m - 1][n - 1];
      }
  };
  ```

  

