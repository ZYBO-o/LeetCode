# 动态规划算法

## 一.动态规划概要

动态规划，英文：Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。

所以动态规划中每一个状态一定是由上一个状态推导出来的，**这一点就区分于贪心**，贪心没有状态推导，而是从局部直接选最优的。

例如：有N件物品和一个最多能背重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和最大。

动态规划中dp[j]是由dp[j-weight[i]]推导出来的，然后取max(dp[j], dp[j - weight[i]] + value[i])。

但如果是贪心呢，每次拿物品选一个最大的或者最小的就完事了，和上一个状态没有关系。

所以贪心解决不了动态规划的问题。

## 二.动态规划解题步骤

**对于动态规划问题，拆解为如下五步曲，这五步都搞清楚了，就能动态规划真的掌握了！**

- **确定dp数组（dp table）以及下标的含义**
- **确定递推公式**
- **dp数组如何初始化**
- **确定遍历顺序**
- **举例推导dp数组**

## 三.动态规划debug方式

写动规题目时，如果代码出问题很正常！

**找问题的最好方式就是把dp数组打印出来，看看究竟是不是按照自己思路推导的！**

**做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果**。

然后再写代码，如果代码没通过就打印dp数组，看看是不是和自己预先推导的哪里不一样。

如果打印出来和自己预先模拟推导是一样的，那么就是自己的递归公式、初始化或者遍历顺序有问题了。

如果和自己预先模拟推导的不一样，那么就是代码实现细节有问题。

**这样才是一个完整的思考过程，而不是一旦代码出问题，就毫无头绪的东改改西改改，最后过不了，或者说是稀里糊涂的过了**。

这也是为什么在动规五步曲里强调推导dp数组的重要性。

如果没有被AC，可以从这三个方面入手检查：

- **这道题目我举例推导状态转移公式了么？**
- **我打印dp数组的日志了么？**
- **打印出来了dp数组和我想的一样么？**

**如果这灵魂三问自己都做到了，基本上这道题目也就解决了**，或者更清晰的知道自己究竟是哪一点不明白，是状态转移不明白，还是实现代码不知道该怎么写，还是不理解遍历dp数组的顺序。



## 四.刷题积累

 ### 1.斐波那契数(509)

> 斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：
> F(0) = 0，F(1) = 1
> F(n) = F(n - 1) + F(n - 2)，其中 n > 1
> 给你n ，请计算 F(n) 。

+ **动态规划五部曲：**

  1. **确定dp数组以及下标的含义**
     + dp[i]的定义为：第i个数的斐波那契数值是dp[i]

  2. **确定递推公式**
     + 为什么这是一道非常简单的入门题目呢？
     + **因为题目已经把递推公式直接给我们了：状态转移方程 dp[i] = dp[i - 1] + dp[i - 2];**

  3. **dp数组如何初始化**

     + **题目中把如何初始化也直接给我们了，如下：**

     ```c++
     dp[0] = 0;
     dp[1] = 1;
     ```

  4. **确定遍历顺序**

     + 从递归公式`dp[i] = dp[i - 1] + dp[i - 2];`中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的

  5. **举例推导dp数组**

     + 按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]，我们来推导一下，当N为10的时候，dp数组应该是如下的数列： 0 1 1 2 3 5 8 13 21 34 55
     + 如果代码写出来，发现结果不对，就把dp数组打印出来看看和我们推导的数列是不是一致的。

+ **代码实现：**

  ```c++
  class Solution {
  public:
      int fib(int n) {
          if(n <= 1)
              return n;
          //1.确定数组和下标意义
          int dp[2];
          //2.确定递推公式
          //dp[i] = dp[i - 1] + dp[1 - 2];
          //3.dp数组初始化
          dp[0] = 0;
          dp[1] = 1;
          //4.确定遍历顺序
          int sum = 0;
          for(int i = 2; i <= n; ++i) {
            //5.推导dp数组
              sum = dp[0] + dp[1];
              dp[0] = dp[1];
              dp[1] = sum;
          }
          return sum;
      }
  };
  ```

  
